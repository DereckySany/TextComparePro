@page "/"
@using CommunityToolkit.Mvvm.Messaging;
@using MauiApp1.Models;
@using System.Text.Json;
@inject MauiApp1.Services.IDialogService dialogService
@inject ICheckIfActivated acService
<MudText Typo="Typo.h4" Align="Align.Center"  class="mb-3">
        Text Tools Pro
</MudText>
<MudTextField T="string" HelperText="Length" Counter="textList[0].Length" Label="Text 1" Variant="Variant.Text" @bind-Value="@textList[0]" Lines="5" />
<MudTextField T="string" HelperText="Length" Counter="textList[1].Length" Label="Text 2" Variant="Variant.Text" @bind-Value="@textList[1]" Lines="5" />
<MudTabs @ref="@Tabs" class="mt-3" Elevation="2" Rounded="true" ApplyEffectsToContainer="true" PanelClass="pa-2">
<MudTabPanel Text="Basic">
<div class="d-flex flex-wrap">
   <MudCheckBox Label="Compare" @bind-Checked="@compare" Color="Color.Primary"></MudCheckBox>
    <MudCheckBox Label="Ignore Case" @bind-Checked="@ignoreCase" Color="Color.Secondary"></MudCheckBox>
    <MudCheckBox Label="Compare Length" @bind-Checked="@lengthCompare" Color="Color.Warning"></MudCheckBox>
    <MudCheckBox Label="Contains" @bind-Checked="@contains" Color="Color.Primary"></MudCheckBox>
    <MudCheckBox Label="Replace" @bind-Checked="@replace" Color="Color.Secondary"></MudCheckBox>
    <MudCheckBox Label="To Upper" @bind-Checked="@toUpper" Color="Color.Warning"></MudCheckBox>
    <MudCheckBox Label="To Lower" @bind-Checked="@toLower" Color="Color.Tertiary"></MudCheckBox>
</div>
</MudTabPanel>
<MudTabPanel Text="Discord (& Markdown)">
<div class="d-flex flex-wrap">
    <MudCheckBox Label="Bold" @bind-Checked="@makeBold" Color="Color.Primary"></MudCheckBox>
    <MudCheckBox Label="Italic" @bind-Checked="@makeItalic" Color="Color.Secondary"></MudCheckBox>
    <MudCheckBox Label="Underline" @bind-Checked="@makeUnderline" Color="Color.Warning"></MudCheckBox>
    <MudCheckBox Label="Strikethrough" @bind-Checked="@makeStrike" Color="Color.Primary"></MudCheckBox>
    <MudCheckBox Label="Spoilers" @bind-Checked="@makeSpoiler" Color="Color.Secondary"></MudCheckBox>
    <MudCheckBox Label="Code Block" @bind-Checked="@makeCode" Color="Color.Warning"></MudCheckBox>
    <MudCheckBox Label="Quote" @bind-Checked="@makeQuote" Color="Color.Tertiary"></MudCheckBox>
    <MudCheckBox Label="Add timestamp" @bind-Checked="@addTimeStamp" Color="Color.Tertiary"></MudCheckBox>
</div>
</MudTabPanel>
<MudTabPanel Text="Text Expander (Accessibility Service)">
        @if (!canTextExpand)
        {
            <MudText class="mb-3">Please provide access to the AccessibilityServices API in order to use this feature. Data collected through the API never leave your device. Providing access will give our accessibility service the ability to replace the keywords you set up with the expanded text, whenever you type on an Entry widget, both inside and outside our app!</MudText>
            <MudButton Color="Color.Primary" Variant="Variant.Outlined" @onclick="OpenSettings">Open Settings</MudButton>
        }
        else {
            <div class="d-flex justify-center">
                <MudButton @onclick="SaveDictAsync" Color="Color.Success" Variant="Variant.Text">Make sure to save!</MudButton>
            </div>
            <MudText class="mb-3">Keywords</MudText>
            <div class="d-flex">
                <MudTextField class="mr-1" Placeholder="t:omw" @bind-Value="currentExpandTuple.Item1" Label="Key" Variant="Variant.Outlined"></MudTextField>
                <MudTextField class="mr-1" Placeholder="On my way" @bind-Value="currentExpandTuple.Item2" Label="Value" Variant="Variant.Outlined"></MudTextField>
                <MudButton @onclick="async () => await AddItemAsync(new KeyValuePair<string, string>(currentExpandTuple.Item1, currentExpandTuple.Item2))" Color="Color.Primary" Variant="Variant.Text">Add</MudButton>
            </div>
            @if (dict is not null)
                {
                    @foreach (var item in dict)
                    {
                        <div class="d-flex mt-2">
                        <MudTextField class="mr-1" Disabled="true" Value="item.Key"  Label="Key" Variant="Variant.Outlined"></MudTextField>
                        <MudTextField class="mr-1" Disabled="true" Value="item.Value" Variant="Variant.Outlined"></MudTextField>
                        <MudButton @onclick="async () => await RemoveItemAsync(item)" Color="Color.Error" Variant="Variant.Text">Delete</MudButton>
                        </div>
                    }

                }
        }
    </MudTabPanel>

</MudTabs>
@if (contains)
{
    <MudTextField class="mt-3" T="string" Label="Contains what?" @bind-Value="@containsText" Variant="Variant.Text" Lines="2" />
}
@if (addTimeStamp)
{
    <MudDatePicker Class="mt-3" Label="Pick a date" @bind-Date="date"/>
    <MudTimePicker Class="mt-3" Label="Pick a time" @bind-Time="timeSpan"/>
}
@if (replace)
{
    <MudTextField class="mt-3" T="string" Label="Replace" @bind-Value="@replaceText" Variant="Variant.Text" Lines="2" />
    <MudTextField class="mt-3" T="string" Label="Replace with?" @bind-Value="@replaceWithText" Variant="Variant.Text" Lines="2" />
}
<MudNumericField Class="mt-3" Label="Process on text number" Min="1" Max="2" @bind-Value="@index"></MudNumericField>
<div class="d-flex justify-center mt-3 mb-3">
    <MudButtonGroup class="mb-3" Variant="Variant.Outlined" Color="Color.Primary">
<MudButton Disabled="@processing" OnClick="Process" >
    @if (processing)
    {
        <MudProgressCircular Class="ms-n1 mr-2" Size="Size.Small" Indeterminate="true"/>
        <MudText Class="ms-2">Processing</MudText>
    }
    else
    {
        <MudText>Process</MudText>
    }
</MudButton>
<MudButton OnClick="async () => await CopyTextAsync(1)">Copy text 1</MudButton>
<MudButton OnClick="async () => await CopyTextAsync(2)">Copy text 2</MudButton>

</MudButtonGroup>
</div>
<MudDivider />
<MudCard class="mt-3 mb-3">
    <MudCardContent>
        <MudText Typo="Typo.h5">RESULTS</MudText>
        <MudText Typo="Typo.h6">PROCESS COUNT: @processCount</MudText>
        <MudDivider class="mb-2 mt-2"/>
        <div class="d-flex flex-wrap">

        <MudCheckBox Label="Is Text Equal" ReadOnly="true" Checked="@compareResult" Color="Color.Success"></MudCheckBox>
        <MudCheckBox Label="Contains the word specified" ReadOnly="true" Checked="@containsResult" Color="Color.Primary"></MudCheckBox>
        <MudCheckBox Label="Is Length Equal" ReadOnly="true" Checked="@lengthCompareResult" Color="Color.Warning"></MudCheckBox>
        <MudCheckBox Label="Can Text Expand" ReadOnly="true" Checked="@canTextExpand" Color="Color.Warning"></MudCheckBox>
        </div>
    </MudCardContent>
</MudCard>
@code{
    List<string> textList = new();
    bool compare = true;
    bool ignoreCase = false;
    bool processing = false;
    bool compareResult = false;
    bool lengthCompare = false;
    bool lengthCompareResult = false;
    bool contains = false;
    string containsText = string.Empty;
    bool containsResult = false;
    int index = 1;
    bool replace = false;
    string replaceText = string.Empty;
    string replaceWithText = string.Empty;
    bool toUpper = false;
    bool toLower = false;
    ulong processCount = 0;
    public MudTabs Tabs;
    bool makeBold = true;
    bool makeItalic = false;
    bool makeStrike = false;
    bool makeCode = false;
    bool makeQuote = false;
    bool makeUnderline = false;
    bool makeSpoiler = false;
    bool addTimeStamp = false;
    bool canTextExpand = false;
    DateTime? date;
    TimeSpan? timeSpan;
    (string, string) currentExpandTuple = (string.Empty, string.Empty);
    private Dictionary<string, string> dict;
    private string DictPath = Path.Combine(FileSystem.Current.CacheDirectory, "keywords.json");
    protected override void OnInitialized()
    {
        base.OnInitialized();
        textList.Add("Enter text - 1");
        textList.Add("Enter text - 2");
        WeakReferenceMessenger.Default.Register<AcServiceMessage>(this, (r, m) =>
        {
            if(!canTextExpand){
                foreach (var item in dict)
                {
                    SendMessage("Add", item);
                }
            }
            canTextExpand = true;
            StateHasChanged();
        });
        canTextExpand = acService.IsActivated();
        if (File.Exists(DictPath))
        {
            using var stream = File.OpenRead(DictPath);
            dict = JsonSerializer.Deserialize<Dictionary<string, string>>(stream);
            if (canTextExpand)
            {
                foreach (var item in dict)
                {
                    SendMessage("Add", item);
                }
            }
        }
        else
            dict = new();
    }
    private async Task AddItemAsync(KeyValuePair<string, string> item)
    {
        try
        {
        dict.Add(item.Key, item.Value);
        SendMessage("Add", item);

        }
        catch (Exception e)
        {
            await dialogService.DisplayConfirmAsync("Error", "Please restart the app to ensure sync" + e.Message);
        }
    }
    private async Task RemoveItemAsync(KeyValuePair<string, string> item)
    {
        try
        {
        dict.Remove(item.Key);
        SendMessage("Remove", item);
        }
        catch (Exception e)
        {
            await dialogService.DisplayConfirmAsync("Error", "Please restart the app to ensure sync" + e.Message);
        }
    }
    private async Task SaveDictAsync(){
        try
        {
            var str = JsonSerializer.Serialize(dict);
            await File.WriteAllTextAsync(DictPath, str);
            await dialogService.DisplayConfirmAsync("Success!", "File saved successfully!");
        }
        catch (Exception e)
        {
            await dialogService.DisplayConfirmAsync("An error occurred!", e.Message);
        }
    }

    private void SendMessage(string cmd, KeyValuePair<string, string> value){
        WeakReferenceMessenger.Default.Send(new AcServiceMessage((cmd, value)));
    }
    private async Task OpenSettings()
    {
        try
        {
            acService.OpenSettings();
        }
        catch (Exception e)
        {
            await dialogService.DisplayConfirmAsync("Error", e.Message);
        }
    }
    private async Task CopyTextAsync(int n)
    {
        await Clipboard.Default.SetTextAsync(textList[n-1]);
        await dialogService.DisplayConfirmAsync("Copied Text", "Copied the text :D");
    }
    private async Task Process()
    {
        processing = true;
        processCount++;
        try
        {
            if (Tabs.ActivePanelIndex == 0)
            {
                if (compare)
                {
                    compareResult = textList[0].Equals(textList[1], ignoreCase ? StringComparison.OrdinalIgnoreCase : StringComparison.Ordinal);
                }
                if (lengthCompare)
                {
                    lengthCompareResult = textList[0].Length == textList[1].Length;
                }
                if (contains)
                {
                    //text 1 only
                    containsResult = textList[index - 1].Contains(containsText, ignoreCase ? StringComparison.OrdinalIgnoreCase : StringComparison.Ordinal);
                }
                if (replace)
                {
                    textList[index - 1] = textList[index - 1].Replace(replaceText, replaceWithText, ignoreCase ? StringComparison.OrdinalIgnoreCase : StringComparison.Ordinal);
                }
                if (toUpper)
                {
                    textList[index - 1] = textList[index - 1].ToUpper();
                }
                if (toLower)
                {
                    textList[index - 1] = textList[index - 1].ToLower();
                }
            }
            else
            {
                if(makeBold)
                {
                    textList[index - 1] = "**" + textList[index - 1] + "**";
                }
                if(makeItalic)
                {
                    textList[index - 1] = "*" + textList[index - 1] + "*";
                }
                if(makeUnderline)
                {
                    textList[index - 1] = "__" + textList[index - 1] + "__";
                }
                if(makeStrike)
                {
                    textList[index - 1] = "~~" + textList[index - 1] + "~~";
                }
                if(makeSpoiler)
                {
                    textList[index - 1] = "||" + textList[index - 1] + "||";
                }
                if(makeCode)
                {
                    textList[index - 1] = "```" + textList[index - 1] + "```";
                }
                if(makeQuote)
                {
                    textList[index - 1] = ">>>" + textList[index - 1];
                }
                if (addTimeStamp)
                {
                    textList[index - 1] += " <t:" + ((DateTimeOffset)(date + timeSpan)).ToUnixTimeSeconds() + ":f>";
                }
            }
        }
        catch (Exception e)
        {
            await dialogService.DisplayConfirmAsync("Error", e.Message);
        }
        processing = false;
    }
}

